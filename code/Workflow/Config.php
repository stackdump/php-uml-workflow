<?
/**
 * Cms_Workflow_Config - Reads an uml file generated by argoUML
 *  All mapping between the config file and the various classes should be done here
 *
 *  Workflows are defined using this UML tool: http://argouml.tigris.org/
 *
 * @todo add more links to document the UML state diagram conventions
 *  also it may be nice to parse the document to get state info using xpath and a dom parser instead of
 *  converting the whole thing to an array
 *
 * @uses Cms_Workflow_Config_Interface
 * @package Cms
 * @subpackage Workflow
 */
class Cms_Workflow_Config implements Cms_Workflow_Config_Interface
{
    private $state_machine; // the state machine data extracted from the UML

    /**
     * __construct - load a workflow config from an argo UML diagram 
     * 
     * @param mixed $uml_file an XMI specification file that contains a state machine
     * @access protected
     * @return void
     */
    function __construct($uml_file)
    { 
        if(! file_exists($uml_file)) throw new Cms_Workflow_Config_Exception('Failed to find :'.$uml_file);

        $xmlObj = new Cms_Xml_Parser(file_get_contents($uml_file));

        $this->data = $xmlObj->createArray();

        //echo '<pre>'; print_r($this->data); echo '</pre>'; die;
    
        //pull the state machine node out of the UML
        $this->getStateMachine();

        //store the transitions, conditions, signals and triggers  where they can be looked up
        $this->loadTransitionDefinitions();
        $this->loadSignalDefinitions();
        $this->loadSignalEventDefinitions();

        unset($this->data);//trash the full file now that we have definitions loaded
    }

    /**
     *   Map the state machine fields onto the Workflow object(s)
     */
    public function getId()
    {
        return $this->state_machine['xmi.id'];
    }

    public function getName()
    {
        return $this->state_machine['name'];
    }

    /**
     * getNodes - parse config and return a list of node objects 
     * 
     *  allow mapping of types to the appropriate set function
     *  @todo allow for the Exit Action 
     *  @todo Add the other actions - instead of having everything be a CallAction type
     *
     * @access public
     * @return array Returns Array of Cms_Workflow_Node
     */
    public function getNodes()
    {
        $nodes = array();
        foreach($this->state_machine['UML:StateMachine.top'][0]['UML:CompositeState'][0]['UML:CompositeState.subvertex'][0]  as $key => $stateTypes)
        {
            $isFirstNode = ($key == 'UML:Pseudostate')? true : false;
            $isLastNode  = ($key == 'UML:FinalState')?  true : false;

            foreach($stateTypes as $state)
            {
                $id   = $state['xmi.id'];
                $name = $state['name'];

                $node_meta = array( 
                        'id'            => $id, 
                        'name'          => $name, 
                        'isFirstNode'   => $isFirstNode,
                        'isLastNode'    => $isLastNode
                        );

                // call the factory method to build a node
                $node = Cms_Workflow_Factory::Node($node_meta);

                /**
                 *  Map correct function to transition types - each type is added to the node with a different method
                 *  in and out transitions are added with different methods
                 */
                $transition_types = array('addInTransition' => 'UML:StateVertex.incoming', 'addOutTransition' => 'UML:StateVertex.outgoing');

                /**
                 *  add both in and out transistions
                 */
                foreach($transition_types as $addTransFunc => $type)
                {
                    /**
                     *  Add transitions to all node types
                     */
                    if( isset($state[$type]) && is_array($state[$type]))
                    {
                        /**
                         *  cycle through all state types 
                         */
                        foreach ($state[$type] as $transitions)
                        {
                            /**
                             * Check to see if this is a single record or an array
                             */
                            if( isset($transitions['UML:Transition']['xmi.idref']))
                            {
                               $transition_ids = array( 0 => $transitions['UML:Transition']);
                            }
                            else // more than one transition
                            {
                               $transition_ids = $transitions['UML:Transition'];
                            }
                            
                            /**
                             *  create a transition object for every id
                             */
                            foreach($transition_ids as $row)
                            {
                                $transition_meta = $this->lookupTransition($row['xmi.idref']);
                                $transition_meta['type'] = $type;

                                //echo "<pre>";  print_r($transition_meta); echo "</pre>";

                                /**
                                 *  Setup transitions then add condition and trigger/eventSignal 
                                 */
                                if(! empty($transition_meta))
                                {
                                    $TransitionObj = Cms_Workflow_Factory::Transition($transition_meta);
                                    $condition_meta = $this->lookupCondition($row['xmi.idref']);
                                    $TransitionObj->setCondition( Cms_Workflow_Factory::Condition($condition_meta ));

                                    if(!$transition_meta['trigger'])
                                    {
                                        //echo "<pre>";  print_r($state); echo "</pre>";
                                        throw new Cms_Workflow_Config_Exception('A Trigger is required for every transition.');
                                    }

                                    $signal_meta = array('name' => $this->lookupTriggerEvent($transition_meta['trigger']));
                                    $TransitionObj->setWorkflowSignal(Cms_Workflow_Factory::Signal($signal_meta));


                                    /**
                                     *  effects on transitions are optional
                                     */
                                    $effect_meta =  $this->lookupEffect($row['xmi.idref']);
                                    if(is_array($effect_meta))
                                    {
                                        //echo "<pre>";  var_dump(array($row , $effect_meta)); echo "</pre>";
                                        $TransitionObj->setEffect(Cms_Workflow_Factory::Effect($effect_meta));
                                    }

                                    //finally add the transition to the Node
                                    $node->$addTransFunc($TransitionObj);
                                }
                            }
                        }
                    }
                }

                /**
                 *  Set actions for this state
                 */
                if(! ($isFirstNode || $isLastNode))
                {
                    
                     //  allow mapping of types to the appropriate set function
                     //  todo allow other types of actions
                    $actionTypesFunc = array(
                        'UML:State.doActivity' => 'setDoActivity', 
                        'UML:State.entry' => 'setEntry');

                    $actions= self::getActionsMeta($state);

                    //echo '<pre>'; print_r($state); echo '</pre>'; die;
                    //echo '<pre>'; print_r($actions); echo '</pre>'; die;
                    foreach($actions as $type => $action_meta)
                    {
                        //echo '<pre>'; print_r($action_meta); echo '</pre>'; die;
                        $setFunc = $actionTypesFunc[$type];
                        $node->$setFunc(Cms_Workflow_Factory::Action($action_meta));
                    }
                }

                $nodes[$id] = $node;
            }
        }

        return $nodes;
    }

    /**
     * getStateMachine - extract just the state machine data from the XMI
     *  NOTE: this looks for the location in a .UML file or .XMI file
     * 
     * @param mixed $data - output from the xml_to_array func
     * @access private
     * @return array - the state machine definition
     */
    private function getStateMachine($data=null)
    {
        if(! $data) $data = &$this->data;

        // check for definition in XMI file
        if( is_array( @$data['XMI']['XMI.content'][0]['UML:Model'][0]['UML:Namespace.ownedElement'][0]['UML:StateMachine']))
        {
            $this->state_machine = &$data['XMI']['XMI.content'][0]['UML:Model'][0]['UML:Namespace.ownedElement'][0]['UML:StateMachine'][0];
            return;
        }

        //look for definition a uml file
        //make sure there is only one model in the UML
        if( count(@$data['uml']['XMI']) !== 1 )
            throw new Cms_Workflow_Config_Exception('Should only be a single XMI model in workflow definition');

        if(! is_array( @$data['uml']['XMI'][0]['XMI.content'][0]['UML:Model'][0]['UML:Namespace.ownedElement'][0]['UML:StateMachine']))
            throw new Cms_Workflow_Config_Exception('Could not find a state machine definition');

        $this->state_machine = &$data['uml']['XMI'][0]['XMI.content'][0]['UML:Model'][0]['UML:Namespace.ownedElement'][0]['UML:StateMachine'][0];
    }

    /**
     * getTransitionDefinitions  - map transition defs from the XMI
     * 
     * @access private
     * @return void
     */
    private function loadTransitionDefinitions()
    {
        //echo '<pre>'; print_r($this->state_machine['UML:StateMachine.transitions']); echo '</pre>'; die;

        $this->transitions = array();
        $this->conditions = array();

        //go through standard transition definitinos
        $this->_loadTransitionDefinitions($this->state_machine['UML:StateMachine.transitions'][0]['UML:Transition']);


        //load internal transitions - these are stored on each node
        $states = $this->state_machine['UML:StateMachine.top'][0]['UML:CompositeState'][0]['UML:CompositeState.subvertex'][0]['UML:SimpleState']; 
        foreach($states as  $state)
        {
            $transitions = @$state['UML:State.internalTransition'][0]['UML:Transition'];
            if( is_array($transitions))
            {
                $this->_loadTransitionDefinitions($transitions, true);
            }
        }

    }

    private function _loadTransitionDefinitions($transitions, $internal = false)
    {
        foreach($transitions as $transition)
        {
            //echo '<pre>'; print_r($transition); echo '</pre>'; 

            $id      =   @$transition['xmi.id'];
            $name    =   @$transition['name']; 
            $trigger =   self::_extractStateId(@$transition['UML:Transition.trigger'][0]);
            $source  =   self::_extractStateId(@$transition['UML:Transition.source' ][0]);
            $target  =   self::_extractStateId(@$transition['UML:Transition.target' ][0]);

            //save transition by id
            $this->transitions[$id] = array( 
                'id' => $id,
                'name' => $name,
                'trigger' => $trigger,
                'target' => $target,
                'internal' => $internal);

            //save the condition by transition_id
            $this->conditions[$id]['script'] = self::_extractConditionExpression($transition);

            if($effect = self::_extractEffectExpression($transition))
            {
                $this->effects[$id]['script'] = $effect;
            }
            //$triggers[]  = $trigger;
        }
    }

    function loadSignalDefinitions()
    {

        //look for the node in an XMI file
        $signal_node =@$this->data['XMI']['XMI.content'][0]['UML:Model'][0]['UML:Namespace.ownedElement'][0]['UML:Signal'];

        if (!$signal_node) //look for the node in a UML file
        {
            $signal_node =@$this->data['uml']['XMI'][0]['XMI.content'][0]['UML:Model'][0]['UML:Namespace.ownedElement'][0]['UML:Signal'];
        }

        //echo '<pre>'; print_r($signal_node); echo '</pre>'; 

        if(! is_array( $signal_node))
        {    
            throw new Cms_Workflow_Config_Exception('could not find uml:signal node');
        }

        /**
         *  stuff into an array if there is only a single def
         */
        if(isset($signal_node['xmi.id'])) $signal_node = array($signal_node);

        $this->signals = array();
        foreach ($signal_node as $signal)
        {
            $this->signals[$signal['xmi.id']] = $signal['name'];
        }
        //echo '<pre>'; print_r($this->signals); echo '</pre>'; 

     }

    /**
     * loadSignalEventDefinitions  - theses signalEvent / Signal relations are sometimes nested
     * 
     * @param mixed $signalEventNode 
     * @static
     * @access public
     * @return void
     */
    function loadSignalEventDefinitions()
    {
        //look inthe loccation for an XMI file
        $signalevent_node =@$this->data['XMI']['XMI.content'][0]['UML:Model'][0]['UML:Namespace.ownedElement'][0]['UML:SignalEvent'];

        if(! $signalevent_node) //look inthe loccation for a UML file
        {
            $signalevent_node =@$this->data['uml']['XMI'][0]['XMI.content'][0]['UML:Model'][0]['UML:Namespace.ownedElement'][0]['UML:SignalEvent'];
        }

        if(! is_array( @$signalevent_node))
        {    
            throw new Cms_Workflow_Config_Exception('could not find uml:signalEvent node');
        }

        $this->signal_events = array();
        foreach ($signalevent_node as $signal)
        {
            if(!  $id = self::_extractSignalId($signal))
            {
                foreach ($signal as $nested)
                {
                    //Save nested relations
                    if( $id = self::_extractSignalId($nested))
                    {
                        $this->signal_events[$nested['xmi.id']] = $id;
                        $this->signal_events[$signal['xmi.id']] = $id;
                    }
                }
            }
            else
            {
                $this->signal_events[$signal['xmi.id']] = $id;
            }

        }

        //echo '<pre>'; print_r($this->signal_events); echo '</pre>'; 
        //echo '<pre>'; print_r($signalevent_node); echo '</pre>'; 
    }

    private function _extractSignalId($row)
    {
        //echo '<pre>'; print_r($row); echo '</pre>'; 
        if( is_array($row))
           return @$row['UML:SignalEvent.signal'][0]['UML:Signal']['xmi.idref'];

        /*
        if( is_array($row) && isset($row['UML:SignalEvent.row'][0]['UML:Signal']['xmi.idref']))
        {
           return $row['UML:SignalEvent.row'][0]['UML:Signal']['xmi.idref'];
        }
        */
        return null;
    }

    private function _extractConditionExpression($transition)
    {
        $script = @$transition['UML:Transition.guard'][0]['UML:Guard'][0]['UML:Guard.expression'][0]['UML:BooleanExpression']['body'];

        if (empty($script))
        {    
            //echo '<pre>'; print_r($transition); echo '</pre>'; 
            throw new Cms_Workflow_Config_Exception('No condition set for transition:'.@$transition['name']);
        }

        return $script;
    }

    private function _extractEffectExpression($transition)
    {
        $script = @$transition['UML:Transition.effect'][0]['UML:CallAction'][0]['UML:Action.script'][0]['UML:ActionExpression']['body'];

        if (isset($transition['UML:Transition.effect']) && empty($script))
        {    
            throw new Cms_Workflow_Config_Exception('Could not find CallAction in transition '.@$transition['name']);
        }

        return $script;
    }

    /**
     * getTansitionId - extract state id from transitions
     * 
     *  Nodes are indexed with a node type, we want to return the referenced node regardless of type
     *
     *  EX: 'UML:SignalEvent' => 
     *    array
     *         'xmi.idref' => string '127-0-1-1--2166a281:12522aaa6e2:-8000:0000000000001113' (length=54)
     *
     * @param mixed $state_reference 
     * @access private
     * @return void
     */
    private function _extractStateId($state_array)
    {
        if(! is_array($state_array)) return;

        $state = current($state_array);

        $id = isset($state['xmi.idref'])? $state['xmi.idref'] : null;

        return $id;
    }

    private function lookupTriggerEvent($trigger)
    {
       /* echo "<pre>";  print_r( array( 'looking for'=>$trigger, $this->signals, $this->signal_events,)); echo "</pre>";*/

        $eventName = $this->signals[$this->signal_events[$trigger]];

        if(!$eventName) throw new Cms_Workflow_Config_Exception('Could not find an event for trigger: '.$trigger);

        return $eventName;
    }

    /**
     * lookupTransition  - lookup transition data by id from the prevously saved definitions
     * transition data is provided in another node from the state defintion
     * we need this function to resolve that info when we create the node
     * 
     * @param string $transition_id  
     * @access private
     * @return transition def
     */
    private function lookupTransition($transition_id)
    {
        if(empty($transition_id)) 
        {
            throw new Cms_Workflow_Config_Exception('Cannot lookup empty transition id');
        }

        if(isset($this->transitions[$transition_id]))
        {
            //echo "<pre>";  print_r($this->transitions[$transition_id]); echo "</pre>";
            return $this->transitions[$transition_id];
        }
       
        //echo "<pre>";  print_r($this->transitions); echo "</pre>";
        $msg = 'No transition definition for: '.$transition_id.
            'NOTE: this may be an accidental internal transition ';

        throw new Cms_Workflow_Config_Exception($msg);
    }

    private function lookupCondition($transition_id)
    {
            return $this->conditions[$transition_id];
    }

    /**
     * lookupEffect  -- effects are optional in a workflow
     * 
     * @param mixed $transition_id 
     * @access private
     * @return void
     */
    private function lookupEffect($transition_id)
    {
        return @$this->effects[$transition_id];
    }

    /**
     * getActionsMeta  - we only support the 2 action types right now - Also must be a CallAction
     * 
     * @param mixed $state_node 
     * @access private
     * @return void
     */
    private function getActionsMeta($state_node)
    {
        $action_types = array('UML:State.doActivity', 'UML:State.entry');

        $return = array();
        foreach($action_types as $type_key)
        {
            $script = @$state_node[$type_key][0]['UML:CallAction'][0]['UML:Action.script'][0]['UML:ActionExpression']['body'];

            if( isset($state_node[$type_key]) && empty($script ))
            {
                throw new Cms_Workflow_Config_Exception('Action.script is missing for action:'.$action_type.' node:'.$state_node['name']);
            }

            if(empty($script)) continue;

            /**
             * currently we only allow php script to be set as an action
             * however the state diagram allows for model references
             */
            $return[$type_key] =  array('script' => $script);

        }

        return $return;
    }

}
